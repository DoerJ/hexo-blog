---
title: Working with Dynamic Component in Angular
date: 2020-10-16
tags: web development, Angular, ag-grid
---
Components are not always pre-defined upon the app initialization, they could be dynamically generated during the runtime. For example, some widgets need to be displayed after user performed some actions on the page, and that means additional view template needs to be inserted into the existing component template. Angular has provided serveral methods to denamically inject content into the template upon the user action, such as using `<ng-container>` as a placeholder for an incoming view and defining that view in `<ng-template>`. In this case, ng-template needs to be pre-defined in the component view and wait to be resolved. But take a step further, is there a way to dynamically define the content and inject into the DOM? Let's use ag-grid, an Angular library that incorporates data with grid layout, to help illustrate such user cases better. 

### A simple user case in ag-grid
One of the most important properties of ag-grid is cellRenderer which defines the view template for the cells of each column of the grid. The following code segment is a simplified version of how cellRenderer is declared and generate template for the cells. For the full details, check out [ag-grid official site](https://www.ag-grid.com/javascript-grid-cell-rendering-components/)
```javascript 
function cellRenderer() {}

MyCellRenderer.prototype.init = function(params) {
    // create the cell
    this.eGui = document.createElement('div');
    this.eGui.innerHTML = '<span class="my-css-class"><button class="btn-simple">Push Me</button><span class="my-value"></span></span>';

    // get references to the elements we want
    this.eButton = this.eGui.querySelector('.btn-simple');
    this.eValue = this.eGui.querySelector('.my-value');

    // set value into cell
    this.eValue.innerHTML = params.valueFormatted ? params.valueFormatted : params.value;

    // add event listener to button
    this.eButton.addEventListener('click', function() {
        console.log('button was clicked!')
    });
};

// gets called once (assuming destroy hasn't been called first) when grid ready to insert the element
MyCellRenderer.prototype.getGui = function() {
    return this.eGui;
};
```
We can see that the view of each cell is coming from `getGui()` method which returns a `HTMLElement` object, and ag-grid takes that returned HTML element and insert into the ag-grid DOM. In this case, the content of cell is dynamically generated by using `document API`. It works, however, imagine what if the view template of cell becomes really complicated? For example, there could be more events other than the click event bound to different elements, some element requires two-way data-bindings of the model vlaues, or even some other components(e.g: calendar, color-picker) are used in the cell template, and so on. Therefore, the complexity of using document API to manually create those HTML element and bind to event could grow dramatically. Furthermore, the component can't be created since the document API doesn't recognize the component as a native HTML element, so we need to initialize that component as a custom element upon the app initialization, which will add another layer of complexity. 

Ideally, getGui method can just return a HTML string that represents the view template of the cell. Similar to the following:
```javascript 
MyCellRenderer.prototype.getGui = function() {
    this.onButtonClick = function() {
        console.log('button was clicked!');
    }
    return '<span class="my-css-class" *ngIf="valid"><button class="btn-simple" (click)="onButtonClick()">Push Me</button><span class="my-value"></span></span>';
}
```
However, the above method won't work in Angular without a little more workaround. The returned HTML string contains the event and directive that come from the Angular context, therefore can't be parsed by the browser. To enable this method in Angular, first we need to parse the the HTML string with Angular compiler so the included Angular events and directives can be interperated under Angular context. One way to think of it is to consider the returned HTML element as a component that has a view template, and we need to dynamically create that component using `ComponentFactory` and inject that component into the corresponding position of DOM tree. 

### A close look to the solution 
Let's create a service that takes in a HTML template, create the component of the view template, and insert the component into the viewContainer of the parent component.
```typescript 
export class DynamicComponentService {
    private static _compiler;
    private static _injector;
    constructor(compiler: Compiler, injector: Injector) {
        DynamicComponentService._compiler = compiler;
        DynamicComponentService._injector = injector;
    }

    static create = function(elements: any, anchor: HTMLElement, container: ViewContainerRef) {
        // template of dynamic component
        const template = elements.template;
        // properties used in template
        const params = elements.params;
        // all dependencies of dynamic component
        const dependencies = elements.dependencies;
        // create an empty component based on the template
        const component = Component({ template: template })(class {});
        var declarations: any[] = [component];
        var imports: any[];
        if(dependencies) {
            declarations = dependencies.components ? [...declarations, ...dependencies.components] : [declarations];
            imports = dependencies.imports ? [...imports, ...dependencies.imports] : [];
        }
        // create a module based on the dynamic component 
        const module = NgModule({ declarations: declarations, imports: imports })(class {});

        DynamicComponentService._compiler.compileModuleAndAllComponentsAsync(module).then(factories => {
            const factory = factories.componentFactories[0];
            const componentRef = factory.create(DynamicComponentService._injector, [], anchor);
            for(let param in params) {
                // assign value to each property of the template
                componentRef.instance[param] = params[param];
            }
            // insert view into the parent component
            container.insert(componentRef.hostView);
        });
    }
}
```
`create()` takes three arguments: an object containing the HTML string and the property values needed for parsing the template, the "achor point" which is a HTML element that marks the position at which the new view template needs to be inserted, and the `viewContainerRef` of the parent component, which can contain the `host view` of a component. The initialization of this dynamic component is very much alike how the static components are loaded in `app.module.ts`, where all the dependencies of the component are also declared and imported into the created module. 

To be able to use DynamicComponentService across the app, we also need to pass in `compiler` and `injector` into the service since the initialization of the module depends on the both.
>app.module.ts
```typescript
export class AppModule {
    constructor(public compiler: Compiler, injector: Injector) {
        new DynamicComponentService(compiler, injector);
    }
}
```





